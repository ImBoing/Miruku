"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$Errors = Symbol('Errors of parsing');
const createErrorOfParse = (line) => new Error(`Unsupported type of line: "${line}"`);
const sectionNameRegex = /\[(.*)]$/;
const autoType = (val) => {
    if ((val === 'true') || (val === 'false')) {
        return val === 'true';
    }
    if (val === '') {
        return true;
    }
    if (!isNaN(parseFloat(val))) {
        return parseFloat(val);
    }
    return val;
};
function parse(data, params) {
    const { delimiter = '=', comment = ';', nothrow = false, autoTyping = true, dataSections = [], } = Object.assign({}, params);
    const lines = data.split(/\r?\n/g);
    let currentSection = '';
    let isDataSection = false;
    const result = {};
    for (const rawLine of lines) {
        const line = rawLine.trim();
        if ((line.length === 0) || (line.startsWith(comment))) {
            continue;
        }
        else if (line[0].startsWith('[')) {
            const match = line.match(sectionNameRegex);
            if (match !== null) {
                currentSection = match[1].trim();
                isDataSection = dataSections.includes(currentSection);
                if (!(currentSection in result)) {
                    result[currentSection] = (isDataSection) ? [] : {};
                }
                continue;
            }
        }
        else if (isDataSection) {
            result[currentSection].push(rawLine);
            continue;
        }
        else if (line.includes(delimiter)) {
            const posOfDelimiter = line.indexOf(delimiter);
            const name = line.slice(0, posOfDelimiter).trim();
            const rawVal = line.slice(posOfDelimiter + 1).trim();
            const val = (autoTyping) ? autoType(rawVal) : rawVal;
            if (currentSection !== '') {
                result[currentSection][name] = val;
            }
            else {
                result[name] = val;
            }
            continue;
        }
        const error = createErrorOfParse(line);
        if (!nothrow) {
            throw error;
        }
        else {
            if (exports.$Errors in result) {
                result[exports.$Errors].push(error);
            }
            else {
                result[exports.$Errors] = [error];
            }
        }
    }
    return result;
}
exports.parse = parse;
function stringify(data, params) {
    const { delimiter = '=', blankLine = true, spaceBefore = false, spaceAfter = false, } = Object.assign({}, params);
    const chunks = [];
    const formatPare = (key, val) => {
        let res = key;
        if (spaceBefore) {
            res += ' ';
        }
        res += delimiter;
        if (spaceAfter) {
            res += ' ';
        }
        res += val;
        return res;
    };
    const sectionKeys = [];
    for (const key of Object.keys(data)) {
        let keyIsAdded = false;
        while ((sectionKeys.length > 0) || !keyIsAdded) {
            const curKey = (keyIsAdded) ? sectionKeys.pop() : key;
            const val = (keyIsAdded) ? data[key][curKey] : data[curKey];
            keyIsAdded = true;
            const valType = typeof val;
            if (['boolean', 'string', 'number'].includes(valType)) {
                chunks.push(formatPare(curKey, val.toString()));
            }
            else if (typeof val === 'object') {
                if (sectionKeys.length > 0) {
                    throw new Error('too much nesting');
                }
                if (blankLine) {
                    chunks.push('');
                }
                chunks.push(`[${key}]`);
                if (Array.isArray(val)) {
                    // is datasection
                    chunks.push(...val);
                }
                else {
                    sectionKeys.push(...Object.keys(val));
                }
            }
        }
    }
    return chunks.join('\n');
}
exports.stringify = stringify;
exports.decode = parse;
exports.encode = stringify;
//# sourceMappingURL=index.js.map